ConstantBuffer RenderObjectData
{
	column_major matrix modelMatrix;
};

ConstantBuffer CameraData
{
	column_major matrix camMatrix;
};

ConstantBuffer LightData
{
	    float3 lightPos;
	  	float4 lightColour;
		float1 lightRadius;
};

struct VS_INPUT
{
	float3 Position		: POSITION0;
	float2 UV			: TEXCOORD0;
	float3 Normal		: TEXCOORD1;
	float3 Tangent		: TEXCOORD2;
};

struct VS_OUTPUT
{
	float4 Position		: S_POSITION;
	float2 UV			: TEXCOORD0;
//	float3 vN;//new
//	float3 vT;
//	float3 binormal ;//new
	//float3 lightPos;
	 //float3	cameraPos;
	 //float3	lightColour;
};

VS_OUTPUT main(VS_INPUT Input)
{
	VS_OUTPUT Output;


Output.Position = mul(mul(camMatrix,modelMatrix), float4(Input.Position.xyz, 1));
	//Output.Color = Input.Color;
	Output.UV = Input.UV;
    //float3	lightPos=float3(1.0f, 1.0f, 1.0f);//test fake light
    //float3	cameraPos=float3(1.0f, 2.0f, 1.0f);//
	//float3	lightColour=float4(1.0f, 1.0f, 1.0f, 1.0f);//
//
//
	//Output.cameraDir = normalize(Input.cameraPos.xyz - Output.Position.xyz);
//	float3 incident = normalize(Input.Position-cameraPos);
	//float3 vN = normalize(mul(float4(Input.Normal,0), mul(camMatrix,modelMatrix)).xyz);
  //  float3 vT = normalize(mul(float4(Input.Tangent,0), mul(camMatrix,modelMatrix)).xyz);
	//Output.lightPos = lightPos;
		//Output.cameraPos = cameraPos;
			//Output.lightColour = lightColour;
	//Output.vN=vN;
	//Output.vT=vT;
//	matrix normalMatrix = transpose ( inverse ( modelMatrix ));



	return Output;
}
